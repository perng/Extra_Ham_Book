\subsection{Discovering HF Digital Modes: The Joy of Variable-Length Character Coding!}

\begin{tcolorbox}[colback=gray!10!white,colframe=black!75!black,title=E2E09] Which of the following HF digital modes uses variable-length character coding?
    \begin{enumerate}[label=\Alph*.]
        \item RTTY
        \item PACTOR
        \item MT63
        \item \textbf{PSK31}
    \end{enumerate}
\end{tcolorbox}

\subsubsection{Intuitive Explanation}
Imagine you are sending a message using a special code. Some codes use the same number of symbols for every letter, like giving every letter the same size box. But other codes, like PSK31, use different sizes for different letters. This is called variable-length character coding. Itâ€™s like packing a suitcase where some items are small and others are big, so you use just the right amount of space for each. PSK31 is smart because it uses shorter codes for common letters like E and longer codes for less common letters like Z. This makes the message faster to send and easier to understand.

\subsubsection{Advanced Explanation}
Variable-length character coding is a method used in data compression and digital communication to represent characters with codes of varying lengths. This technique is based on the principle of assigning shorter codes to more frequently occurring characters and longer codes to less frequently occurring ones. PSK31, a popular HF digital mode, employs this method to optimize bandwidth usage and improve transmission efficiency.

In PSK31, the coding scheme is derived from the Varicode, which is a form of Huffman coding. Huffman coding is a lossless data compression algorithm that uses a binary tree to assign codes to characters based on their frequency of occurrence. For example, the letter E (which is very common in English) might be represented by a short code like 10, while the letter Q (which is less common) might be represented by a longer code like 11010.

The mathematical foundation of Huffman coding involves constructing a binary tree where each leaf node represents a character and its frequency. The tree is built by repeatedly combining the two nodes with the lowest frequencies until all nodes are merged into a single tree. The codes are then derived by traversing the tree from the root to each leaf, assigning a 0 for each left branch and a 1 for each right branch.

For example, consider the following simplified frequency table:

\begin{center}
\begin{tabular}{|c|c|}
\hline
Character & Frequency \\
\hline
E & 12 \\
T & 9 \\
A & 8 \\
Q & 1 \\
\hline
\end{tabular}
\end{center}

The Huffman tree would be constructed as follows:
\begin{enumerate}
    \item Combine Q (1) and A (8) to form a new node with frequency 9.
    \item Combine T (9) with the new node (9) to form a node with frequency 18.
    \item Combine E (12) with the node (18) to form the root node with frequency 30.
\end{enumerate}

The resulting codes might be:
\begin{itemize}
    \item E: 0
    \item T: 10
    \item A: 110
    \item Q: 111
\end{itemize}

This variable-length coding allows PSK31 to transmit messages more efficiently than fixed-length coding modes like RTTY, PACTOR, or MT63.

% Diagram prompt: Generate a diagram showing the Huffman tree construction process for the given frequency table.